package main

import (
	"fmt"
	"github.com/davecheney/i2c"
	"log"
	"time"
)

// 8x8 graphic font, properly rotated for the display

var font8x8_basic = [...]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x5F, 0x5F, 0x06, 0x00, 0x00,
	0x00, 0x00, 0x03, 0x03, 0x00, 0x03, 0x03, 0x00,
	0x00, 0x14, 0x7F, 0x7F, 0x14, 0x7F, 0x7F, 0x14,
	0x00, 0x00, 0x12, 0x3A, 0x6B, 0x6B, 0x2E, 0x24,
	0x00, 0x62, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x46,
	0x00, 0x48, 0x7A, 0x37, 0x5D, 0x4F, 0x7A, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x04,
	0x00, 0x00, 0x00, 0x41, 0x63, 0x3E, 0x1C, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x3E, 0x63, 0x41, 0x00,
	0x08, 0x2A, 0x3E, 0x1C, 0x1C, 0x3E, 0x2A, 0x08,
	0x00, 0x00, 0x08, 0x08, 0x3E, 0x3E, 0x08, 0x08,
	0x00, 0x00, 0x00, 0x00, 0x60, 0xE0, 0x80, 0x00,
	0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00,
	0x00, 0x01, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60,
	0x00, 0x3E, 0x7F, 0x4D, 0x59, 0x71, 0x7F, 0x3E,
	0x00, 0x00, 0x40, 0x40, 0x7F, 0x7F, 0x42, 0x40,
	0x00, 0x00, 0x66, 0x6F, 0x49, 0x59, 0x73, 0x62,
	0x00, 0x00, 0x36, 0x7F, 0x49, 0x49, 0x63, 0x22,
	0x00, 0x50, 0x7F, 0x7F, 0x53, 0x16, 0x1C, 0x18,
	0x00, 0x00, 0x39, 0x7D, 0x45, 0x45, 0x67, 0x27,
	0x00, 0x00, 0x30, 0x79, 0x49, 0x4B, 0x7E, 0x3C,
	0x00, 0x00, 0x07, 0x0F, 0x79, 0x71, 0x03, 0x03,
	0x00, 0x00, 0x36, 0x7F, 0x49, 0x49, 0x7F, 0x36,
	0x00, 0x00, 0x1E, 0x3F, 0x69, 0x49, 0x4F, 0x06,
	0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x66, 0xE6, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x41, 0x63, 0x36, 0x1C, 0x08,
	0x00, 0x00, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
	0x00, 0x00, 0x08, 0x1C, 0x36, 0x63, 0x41, 0x00,
	0x00, 0x00, 0x06, 0x0F, 0x59, 0x51, 0x03, 0x02,
	0x00, 0x1E, 0x1F, 0x5D, 0x5D, 0x41, 0x7F, 0x3E,
	0x00, 0x00, 0x7C, 0x7E, 0x13, 0x13, 0x7E, 0x7C,
	0x00, 0x36, 0x7F, 0x49, 0x49, 0x7F, 0x7F, 0x41,
	0x00, 0x22, 0x63, 0x41, 0x41, 0x63, 0x3E, 0x1C,
	0x00, 0x1C, 0x3E, 0x63, 0x41, 0x7F, 0x7F, 0x41,
	0x00, 0x63, 0x41, 0x5D, 0x49, 0x7F, 0x7F, 0x41,
	0x00, 0x03, 0x01, 0x1D, 0x49, 0x7F, 0x7F, 0x41,
	0x00, 0x72, 0x73, 0x51, 0x41, 0x63, 0x3E, 0x1C,
	0x00, 0x00, 0x7F, 0x7F, 0x08, 0x08, 0x7F, 0x7F,
	0x00, 0x00, 0x00, 0x41, 0x7F, 0x7F, 0x41, 0x00,
	0x00, 0x01, 0x3F, 0x7F, 0x41, 0x40, 0x70, 0x30,
	0x00, 0x63, 0x77, 0x1C, 0x08, 0x7F, 0x7F, 0x41,
	0x00, 0x70, 0x60, 0x40, 0x41, 0x7F, 0x7F, 0x41,
	0x00, 0x7F, 0x7F, 0x0E, 0x1C, 0x0E, 0x7F, 0x7F,
	0x00, 0x7F, 0x7F, 0x18, 0x0C, 0x06, 0x7F, 0x7F,
	0x00, 0x1C, 0x3E, 0x63, 0x41, 0x63, 0x3E, 0x1C,
	0x00, 0x06, 0x0F, 0x09, 0x49, 0x7F, 0x7F, 0x41,
	0x00, 0x00, 0x5E, 0x7F, 0x71, 0x21, 0x3F, 0x1E,
	0x00, 0x66, 0x7F, 0x19, 0x09, 0x7F, 0x7F, 0x41,
	0x00, 0x00, 0x32, 0x73, 0x59, 0x4D, 0x6F, 0x26,
	0x00, 0x00, 0x03, 0x41, 0x7F, 0x7F, 0x41, 0x03,
	0x00, 0x00, 0x7F, 0x7F, 0x40, 0x40, 0x7F, 0x7F,
	0x00, 0x00, 0x1F, 0x3F, 0x60, 0x60, 0x3F, 0x1F,
	0x00, 0x7F, 0x7F, 0x30, 0x18, 0x30, 0x7F, 0x7F,
	0x00, 0x43, 0x67, 0x3C, 0x18, 0x3C, 0x67, 0x43,
	0x00, 0x00, 0x07, 0x4F, 0x78, 0x78, 0x4F, 0x07,
	0x00, 0x73, 0x67, 0x4D, 0x59, 0x71, 0x63, 0x47,
	0x00, 0x00, 0x00, 0x41, 0x41, 0x7F, 0x7F, 0x00,
	0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01,
	0x00, 0x00, 0x00, 0x7F, 0x7F, 0x41, 0x41, 0x00,
	0x00, 0x08, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x08,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x00, 0x00, 0x00, 0x04, 0x07, 0x03, 0x00, 0x00,
	0x00, 0x40, 0x78, 0x3C, 0x54, 0x54, 0x74, 0x20,
	0x00, 0x30, 0x78, 0x48, 0x48, 0x3F, 0x7F, 0x41,
	0x00, 0x00, 0x28, 0x6C, 0x44, 0x44, 0x7C, 0x38,
	0x00, 0x40, 0x7F, 0x3F, 0x49, 0x48, 0x78, 0x30,
	0x00, 0x00, 0x18, 0x5C, 0x54, 0x54, 0x7C, 0x38,
	0x00, 0x00, 0x02, 0x03, 0x49, 0x7F, 0x7E, 0x48,
	0x00, 0x04, 0x7C, 0xF8, 0xA4, 0xA4, 0xBC, 0x98,
	0x00, 0x78, 0x7C, 0x04, 0x08, 0x7F, 0x7F, 0x41,
	0x00, 0x00, 0x00, 0x40, 0x7D, 0x7D, 0x44, 0x00,
	0x00, 0x00, 0x7D, 0xFD, 0x80, 0x80, 0xE0, 0x60,
	0x00, 0x44, 0x6C, 0x38, 0x10, 0x7F, 0x7F, 0x41,
	0x00, 0x00, 0x00, 0x40, 0x7F, 0x7F, 0x41, 0x00,
	0x00, 0x78, 0x7C, 0x1C, 0x38, 0x18, 0x7C, 0x7C,
	0x00, 0x00, 0x78, 0x7C, 0x04, 0x04, 0x7C, 0x7C,
	0x00, 0x00, 0x38, 0x7C, 0x44, 0x44, 0x7C, 0x38,
	0x00, 0x18, 0x3C, 0x24, 0xA4, 0xF8, 0xFC, 0x84,
	0x00, 0x84, 0xFC, 0xF8, 0xA4, 0x24, 0x3C, 0x18,
	0x00, 0x18, 0x1C, 0x04, 0x4C, 0x78, 0x7C, 0x44,
	0x00, 0x00, 0x24, 0x74, 0x54, 0x54, 0x5C, 0x48,
	0x00, 0x00, 0x24, 0x44, 0x7F, 0x3E, 0x04, 0x00,
	0x00, 0x40, 0x7C, 0x3C, 0x40, 0x40, 0x7C, 0x3C,
	0x00, 0x00, 0x1C, 0x3C, 0x60, 0x60, 0x3C, 0x1C,
	0x00, 0x3C, 0x7C, 0x70, 0x38, 0x70, 0x7C, 0x3C,
	0x00, 0x44, 0x6C, 0x38, 0x10, 0x38, 0x6C, 0x44,
	0x00, 0x00, 0x7C, 0xFC, 0xA0, 0xA0, 0xBC, 0x9C,
	0x00, 0x00, 0x64, 0x4C, 0x5C, 0x74, 0x64, 0x4C,
	0x00, 0x00, 0x41, 0x41, 0x77, 0x3E, 0x08, 0x08,
	0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x08, 0x08, 0x3E, 0x77, 0x41, 0x41,
	0x00, 0x01, 0x03, 0x02, 0x03, 0x01, 0x03, 0x02,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

// Global variables

var lcdbuf [1024]byte      // LCD screen buffer
var uatCur uint            // Current UAT/min
var uatMax uint            // Max UAT
var esCur uint             // Current ES/min
var esMax uint             // Max ES
var blinker byte           // Used for rotating character in upper left
var textLine1Position byte // Used to indicate what is on 1st and second line
var textLine2Position byte

func check(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

//var i2cg *i2c.I2C

func write_reg(i2c *i2c.I2C, val byte) {
	buf := make([]byte, 2)
	buf[0] = 0
	buf[1] = val
	i2c.Write(buf)
}

func copyMemory(i2cg *i2c.I2C) {
	outbuf := make([]byte, 1025)

	write_reg(i2cg, 0x00)
	write_reg(i2cg, 0x10)

	outbuf[0] = 0x40
	for i := 0; i < 1024; i++ {
		outbuf[i+1] = lcdbuf[i]
	}
	i2cg.Write(outbuf)
}

func draw_graph(pos uint, cur uint, max uint) {
	// Graphs go from 32 to 96, so 64 steps
	var scale uint
	scale = 0
	if max != 0 {
		scale = 640000 / max
	}
	len := (int)((scale * cur) / 10000)
	if len > 63 {
		len = 63
	}
	if len <= 0 {
		len = 1
	}
	// So now len contains the length
	lcdpos := (128 * pos) + 32
	for x := 0; x < len; x++ {
		lcdbuf[lcdpos] = 0x7e
		lcdpos = lcdpos + 1
	}
	for y := len; y < 64; y++ {
		lcdbuf[lcdpos] = 0
		lcdpos = lcdpos + 1
	}

}

func draw_text(col int, row int, str string) {

	var p int
	pos := (128 * row)
	if col == -1 {
		stWidth := len(str) * 8
		stWidth = stWidth / 2
		if stWidth > 63 {
			stWidth = 63
		}
		pos = pos + (64 - stWidth)
	} else {
		pos = pos + (col)
	}
	for j := 0; j < len(str); j++ {
		p = int(str[j])
		p = p * 8
		for i := 0; i < 8; i++ {
			scPos := pos + i
			if scPos < 1024 {
				lcdbuf[scPos] = font8x8_basic[p+7-i]
			}
		}
		pos += 8
	}
}

func clearLine(line int) {
	pos := (128 * line)
	for i := 0; i < 128; i++ {
		lcdbuf[pos+i] = 0
	}
}

func displayInfo(marquee byte, marquee2 byte) {
	var str string
	var blinkstr string
	var UATTowers int

	// Count the UAT towers seen
	UATTowers = 0
	for _, twr := range ADSBTowers {
		if twr.Messages_last_minute > 0 {
			UATTowers++
		}
	}
	switch blinker {
	case 0:
		blinkstr = "-"
	case 1:
		blinkstr = "\\"
	case 2:
		blinkstr = "|"
	case 3:
		blinkstr = "/"
	case 4:
		blinkstr = "-"
	case 5:
		blinkstr = "\\"
	case 6:
		blinkstr = "|"
	case 7:
		blinkstr = "/"
	}
	blinker++
	blinker &= 7
	draw_text(0, 0, blinkstr)
	draw_text(55, 0, "UAT")
	str = fmt.Sprintf("T %d", UATTowers)
	draw_text(104, 0, str)
	clearLine(1)
	str = fmt.Sprintf("%d", uatCur)
	draw_text(0, 1, str)
	str = fmt.Sprintf("%4d", uatMax)
	draw_text(96, 1, str)
	draw_graph(1, uatCur, uatMax)
	draw_text(40, 3, "1090ES")
	clearLine(4)
	str = fmt.Sprintf("%d", esCur)
	draw_text(0, 4, str)
	str = fmt.Sprintf("%4d", esMax)
	draw_text(96, 4, str)
	draw_graph(4, esCur, esMax)
	clearLine(6)
	switch marquee {
	case 0:
		str = fmt.Sprintf("Vers %s", globalStatus.Version)
		draw_text(-1, 6, str)
	case 1:
		str = fmt.Sprintf("Temp %2.1fC", globalStatus.CPUTemp)
		draw_text(-1, 6, str)
	case 2:
		str = fmt.Sprintf("Clients %d", globalStatus.Connected_Users)
		draw_text(-1, 6, str)
	case 3:
		upTimeS := (globalStatus.Uptime / 1000) % 60
		upTimeM := (globalStatus.Uptime / (1000 * 60)) % 60
		upTimeH := (globalStatus.Uptime / (1000 * 3600))
		str = fmt.Sprintf("Up %02d:%02d:%02d", upTimeH, upTimeM, upTimeS)
		draw_text(-1, 6, str)
	}
	clearLine(7)
	switch marquee2 {
	case 0:
		str = fmt.Sprintf("Lon %3.7f", mySituation.Lng)
		draw_text(-1, 7, str)
	case 1:
		str = fmt.Sprintf("Lon %3.7f", mySituation.Lat)
		draw_text(-1, 7, str)
	case 2:
		str = fmt.Sprintf("Alt %5.0f", mySituation.Alt)
		draw_text(-1, 7, str)
	case 3:
		str = fmt.Sprintf("Speed %d", mySituation.GroundSpeed)
		draw_text(-1, 7, str)
	case 4:
		str = fmt.Sprintf("%d sats", globalStatus.GPS_satellites_locked)
		draw_text(-1, 7, str)
	}
}

func initDisplay(i2c *i2c.I2C) {
	write_reg(i2c, 0xAE)

	write_reg(i2c, 0xD5)
	write_reg(i2c, 0x80)

	/* Set Multiplex Ratio */
	write_reg(i2c, 0xA8)
	write_reg(i2c, 0x3f)

	/* Set Display Offset */
	write_reg(i2c, 0xD3)
	write_reg(i2c, 0x00)

	/* Set Display Start Line */
	write_reg(i2c, 0x40|0)

	/* Charge Pump Setting */
	write_reg(i2c, 0x8D)
	/* A[2] = 1b, Enable charge pump during display on */
	write_reg(i2c, 0x14)

	/* Set Memory Addressing Mode */
	write_reg(i2c, 0x20)
	/* Vertical addressing mode  */
	write_reg(i2c, 0x00)

	/* Set COM Output Scan Direction */
	/* remapped mode. Scan from COM[N-1] to COM0 */
	write_reg(i2c, 0xC0)

	/* Set COM Pins Hardware Configuration */
	write_reg(i2c, 0xDA)
	write_reg(i2c, 0x12)

	/* Set Pre-charge Period */
	write_reg(i2c, 0xD9)
	write_reg(i2c, 0xF1)

	/* Set VCOMH Deselect Level */
	write_reg(i2c, 0xDB)
	/* according to the datasheet, this value is out of bounds */
	write_reg(i2c, 0x40)

	/* Entire Display ON */
	/* Resume to RAM content display. Output follows RAM content */
	write_reg(i2c, 0xA4)

	/* Set Normal Display
	   0 in RAM: OFF in display panel
	   1 in RAM: ON in display panel */
	write_reg(i2c, 0xA6)

	/* Set Display ON */
	write_reg(i2c, 0xAF)
}

func displayLoop(i2c *i2c.I2C) {
	timer := time.NewTicker(500 * time.Millisecond)
	timerLine1 := time.NewTicker(5 * time.Second)
	timerLine2 := time.NewTicker(3 * time.Second)
	for {
		select {
		case <-timer.C:
			displayInfo(textLine1Position, textLine2Position)
			copyMemory(i2c)
			uatCur = globalStatus.UAT_messages_last_minute
			uatMax = globalStatus.UAT_messages_max
			esCur = globalStatus.ES_messages_last_minute
			esMax = globalStatus.ES_messages_max
			if uatCur < 0 {
				uatCur = 0
			}
			if esCur < 0 {
				esCur = 0
			}
			if uatCur > 999 {
				uatCur = 999
			}
			if esCur > 9999 {
				esCur = 9999
			}
		case <-timerLine1.C:
			textLine1Position++
			if textLine1Position > 3 {
				textLine1Position = 0
			}
		case <-timerLine2.C:
			textLine2Position++
			if textLine2Position > 4 {
				textLine2Position = 0
			}

		}
	}
}

// Main OLED display section
func oled_display() {
	// Open the I2C port
	i2c, err := i2c.New(0x3c, 1)
	check(err)

	// Clear the statistics
	uatCur = 0
	uatMax = 0
	esCur = 0
	esMax = 0

	textLine1Position = 0
	textLine2Position = 0

	// clear the screen
	for i := 0; i < 1024; i++ {
		lcdbuf[i] = 0
	}

	// Set up the display
	initDisplay(i2c)

	// Run the display loop
	displayLoop(i2c)
}
